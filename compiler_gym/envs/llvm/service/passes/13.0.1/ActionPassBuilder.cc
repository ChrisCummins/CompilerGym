// Copyright (c) Facebook, Inc. and its affiliates.
//
// This source code is licensed under the MIT license found in the
// LICENSE file in the root directory of this source tree.
//
// This file was automatically generated by make_action_space_sources.py.
#include "llvm/Passes/PassBuilder.h"
#include "llvm/Transforms/AggressiveInstCombine/AggressiveInstCombine.h"
#include "llvm/Transforms/Coroutines/CoroCleanup.h"
#include "llvm/Transforms/Coroutines/CoroEarly.h"
#include "llvm/Transforms/Coroutines/CoroElide.h"
#include "llvm/Transforms/IPO/AlwaysInliner.h"
#include "llvm/Transforms/IPO/Annotation2Metadata.h"
#include "llvm/Transforms/IPO/Attributor.h"
#include "llvm/Transforms/IPO/BlockExtractor.h"
#include "llvm/Transforms/IPO/CalledValuePropagation.h"
#include "llvm/Transforms/IPO/ConstantMerge.h"
#include "llvm/Transforms/IPO/CrossDSOCFI.h"
#include "llvm/Transforms/IPO/DeadArgumentElimination.h"
#include "llvm/Transforms/IPO/ElimAvailExtern.h"
#include "llvm/Transforms/IPO/ForceFunctionAttrs.h"
#include "llvm/Transforms/IPO/FunctionAttrs.h"
#include "llvm/Transforms/IPO/FunctionImport.h"
#include "llvm/Transforms/IPO/GlobalDCE.h"
#include "llvm/Transforms/IPO/GlobalOpt.h"
#include "llvm/Transforms/IPO/GlobalSplit.h"
#include "llvm/Transforms/IPO/HotColdSplitting.h"
#include "llvm/Transforms/IPO/IROutliner.h"
#include "llvm/Transforms/IPO/InferFunctionAttrs.h"
#include "llvm/Transforms/IPO/Inliner.h"
#include "llvm/Transforms/IPO/Internalize.h"
#include "llvm/Transforms/IPO/LoopExtractor.h"
#include "llvm/Transforms/IPO/LowerTypeTests.h"
#include "llvm/Transforms/IPO/MergeFunctions.h"
#include "llvm/Transforms/IPO/OpenMPOpt.h"
#include "llvm/Transforms/IPO/PartialInlining.h"
#include "llvm/Transforms/IPO/SCCP.h"
#include "llvm/Transforms/IPO/SampleProfile.h"
#include "llvm/Transforms/IPO/SampleProfileProbe.h"
#include "llvm/Transforms/IPO/StripDeadPrototypes.h"
#include "llvm/Transforms/IPO/StripSymbols.h"
#include "llvm/Transforms/IPO/SyntheticCountsPropagation.h"
#include "llvm/Transforms/IPO/WholeProgramDevirt.h"
#include "llvm/Transforms/InstCombine/InstCombine.h"
#include "llvm/Transforms/ObjCARC.h"
#include "llvm/Transforms/Scalar/ADCE.h"
#include "llvm/Transforms/Scalar/AlignmentFromAssumptions.h"
#include "llvm/Transforms/Scalar/AnnotationRemarks.h"
#include "llvm/Transforms/Scalar/BDCE.h"
#include "llvm/Transforms/Scalar/CallSiteSplitting.h"
#include "llvm/Transforms/Scalar/ConstantHoisting.h"
#include "llvm/Transforms/Scalar/ConstraintElimination.h"
#include "llvm/Transforms/Scalar/CorrelatedValuePropagation.h"
#include "llvm/Transforms/Scalar/DCE.h"
#include "llvm/Transforms/Scalar/DFAJumpThreading.h"
#include "llvm/Transforms/Scalar/DeadStoreElimination.h"
#include "llvm/Transforms/Scalar/DivRemPairs.h"
#include "llvm/Transforms/Scalar/EarlyCSE.h"
#include "llvm/Transforms/Scalar/Float2Int.h"
#include "llvm/Transforms/Scalar/GVN.h"
#include "llvm/Transforms/Scalar/GuardWidening.h"
#include "llvm/Transforms/Scalar/InductiveRangeCheckElimination.h"
#include "llvm/Transforms/Scalar/InferAddressSpaces.h"
#include "llvm/Transforms/Scalar/InstSimplifyPass.h"
#include "llvm/Transforms/Scalar/JumpThreading.h"
#include "llvm/Transforms/Scalar/LoopDataPrefetch.h"
#include "llvm/Transforms/Scalar/LoopDistribute.h"
#include "llvm/Transforms/Scalar/LoopFuse.h"
#include "llvm/Transforms/Scalar/LoopLoadElimination.h"
#include "llvm/Transforms/Scalar/LoopSink.h"
#include "llvm/Transforms/Scalar/LoopUnrollPass.h"
#include "llvm/Transforms/Scalar/LowerAtomic.h"
#include "llvm/Transforms/Scalar/LowerConstantIntrinsics.h"
#include "llvm/Transforms/Scalar/LowerExpectIntrinsic.h"
#include "llvm/Transforms/Scalar/LowerGuardIntrinsic.h"
#include "llvm/Transforms/Scalar/LowerMatrixIntrinsics.h"
#include "llvm/Transforms/Scalar/LowerWidenableCondition.h"
#include "llvm/Transforms/Scalar/MakeGuardsExplicit.h"
#include "llvm/Transforms/Scalar/MemCpyOptimizer.h"
#include "llvm/Transforms/Scalar/MergeICmps.h"
#include "llvm/Transforms/Scalar/MergedLoadStoreMotion.h"
#include "llvm/Transforms/Scalar/NaryReassociate.h"
#include "llvm/Transforms/Scalar/NewGVN.h"
#include "llvm/Transforms/Scalar/PartiallyInlineLibCalls.h"
#include "llvm/Transforms/Scalar/Reassociate.h"
#include "llvm/Transforms/Scalar/Reg2Mem.h"
#include "llvm/Transforms/Scalar/RewriteStatepointsForGC.h"
#include "llvm/Transforms/Scalar/SCCP.h"
#include "llvm/Transforms/Scalar/SROA.h"
#include "llvm/Transforms/Scalar/ScalarizeMaskedMemIntrin.h"
#include "llvm/Transforms/Scalar/Scalarizer.h"
#include "llvm/Transforms/Scalar/SeparateConstOffsetFromGEP.h"
#include "llvm/Transforms/Scalar/SimplifyCFG.h"
#include "llvm/Transforms/Scalar/Sink.h"
#include "llvm/Transforms/Scalar/SpeculativeExecution.h"
#include "llvm/Transforms/Scalar/StraightLineStrengthReduce.h"
#include "llvm/Transforms/Scalar/StructurizeCFG.h"
#include "llvm/Transforms/Scalar/TailRecursionElimination.h"
#include "llvm/Transforms/Scalar/WarnMissedTransforms.h"
#include "llvm/Transforms/Utils/AddDiscriminators.h"
#include "llvm/Transforms/Utils/AssumeBundleBuilder.h"
#include "llvm/Transforms/Utils/BreakCriticalEdges.h"
#include "llvm/Transforms/Utils/CanonicalizeAliases.h"
#include "llvm/Transforms/Utils/FixIrreducible.h"
#include "llvm/Transforms/Utils/HelloWorld.h"
#include "llvm/Transforms/Utils/InjectTLIMappings.h"
#include "llvm/Transforms/Utils/InstructionNamer.h"
#include "llvm/Transforms/Utils/LCSSA.h"
#include "llvm/Transforms/Utils/LibCallsShrinkWrap.h"
#include "llvm/Transforms/Utils/LoopSimplify.h"
#include "llvm/Transforms/Utils/LoopVersioning.h"
#include "llvm/Transforms/Utils/LowerInvoke.h"
#include "llvm/Transforms/Utils/LowerSwitch.h"
#include "llvm/Transforms/Utils/Mem2Reg.h"
#include "llvm/Transforms/Utils/MetaRenamer.h"
#include "llvm/Transforms/Utils/NameAnonGlobals.h"
#include "llvm/Transforms/Utils/PredicateInfo.h"
#include "llvm/Transforms/Utils/RelLookupTableConverter.h"
#include "llvm/Transforms/Utils/StripGCRelocates.h"
#include "llvm/Transforms/Utils/StripNonLineTableDebugInfo.h"
#include "llvm/Transforms/Utils/SymbolRewriter.h"
#include "llvm/Transforms/Utils/UnifyFunctionExitNodes.h"
#include "llvm/Transforms/Utils/UnifyLoopExits.h"
#include "llvm/Transforms/Vectorize/LoadStoreVectorizer.h"
#include "llvm/Transforms/Vectorize/LoopVectorize.h"
#include "llvm/Transforms/Vectorize/SLPVectorizer.h"
#include "llvm/Transforms/Vectorize/VectorCombine.h"

llvm::ModulePassManager createPassManagerFromAction(CompilerGymPass action) {
  llvm::ModulePassManager pm;
  addActionToPassManager(action, pm);
  return pm;
}

void addActionToPassManager(CompilerGymPass action, llvm::ModulePassManager& pm) {
  llvm::FunctionPassManager fpm;
  switch (action) {
    case CompilerGymPass::ADCE:
      fpm.addPass(llvm::ADCEPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::ADD_DISCRIMINATORS:
      fpm.addPass(llvm::AddDiscriminatorsPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::AGGRESSIVE_INST_COMBINE:
      fpm.addPass(llvm::AggressiveInstCombinePass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::ALIGNMENT_FROM_ASSUMPTIONS:
      fpm.addPass(llvm::AlignmentFromAssumptionsPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::ALWAYS_INLINER:
      pm.addPass(llvm::AlwaysInlinerPass());
      break;
    case CompilerGymPass::ANNOTATION2METADATA:
      pm.addPass(llvm::Annotation2MetadataPass());
      break;
    case CompilerGymPass::ANNOTATION_REMARKS:
      fpm.addPass(llvm::AnnotationRemarksPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::ASSUME_BUILDER:
      fpm.addPass(llvm::AssumeBuilderPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::ASSUME_SIMPLIFY:
      fpm.addPass(llvm::AssumeSimplifyPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::ATTRIBUTOR:
      pm.addPass(llvm::AttributorPass());
      break;
    case CompilerGymPass::BDCE:
      fpm.addPass(llvm::BDCEPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::BLOCK_EXTRACTOR:
      pm.addPass(llvm::BlockExtractorPass());
      break;
    case CompilerGymPass::BREAK_CRITICAL_EDGES:
      fpm.addPass(llvm::BreakCriticalEdgesPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::CALL_SITE_SPLITTING:
      fpm.addPass(llvm::CallSiteSplittingPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::CALLED_VALUE_PROPAGATION:
      pm.addPass(llvm::CalledValuePropagationPass());
      break;
    case CompilerGymPass::CANONICALIZE_ALIASES:
      pm.addPass(llvm::CanonicalizeAliasesPass());
      break;
    case CompilerGymPass::CONSTANT_HOISTING:
      fpm.addPass(llvm::ConstantHoistingPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::CONSTANT_MERGE:
      pm.addPass(llvm::ConstantMergePass());
      break;
    case CompilerGymPass::CONSTRAINT_ELIMINATION:
      fpm.addPass(llvm::ConstraintEliminationPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::CORO_CLEANUP:
      fpm.addPass(llvm::CoroCleanupPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::CORO_EARLY:
      fpm.addPass(llvm::CoroEarlyPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::CORO_ELIDE:
      fpm.addPass(llvm::CoroElidePass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::CORRELATED_VALUE_PROPAGATION:
      fpm.addPass(llvm::CorrelatedValuePropagationPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::CROSS_DSOCFI:
      pm.addPass(llvm::CrossDSOCFIPass());
      break;
    case CompilerGymPass::DCE:
      fpm.addPass(llvm::DCEPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::DFAJUMP_THREADING:
      fpm.addPass(llvm::DFAJumpThreadingPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::DSE:
      fpm.addPass(llvm::DSEPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::DEAD_ARGUMENT_ELIMINATION:
      pm.addPass(llvm::DeadArgumentEliminationPass());
      break;
    case CompilerGymPass::DIV_REM_PAIRS:
      fpm.addPass(llvm::DivRemPairsPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::EARLY_CSE:
      fpm.addPass(llvm::EarlyCSEPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::ELIMINATE_AVAILABLE_EXTERNALLY:
      pm.addPass(llvm::EliminateAvailableExternallyPass());
      break;
    case CompilerGymPass::FIX_IRREDUCIBLE:
      fpm.addPass(llvm::FixIrreduciblePass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::FLOAT2INT:
      fpm.addPass(llvm::Float2IntPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::FORCE_FUNCTION_ATTRS:
      pm.addPass(llvm::ForceFunctionAttrsPass());
      break;
    case CompilerGymPass::FUNCTION_IMPORT:
      pm.addPass(llvm::FunctionImportPass());
      break;
    case CompilerGymPass::FUNCTION_SPECIALIZATION:
      pm.addPass(llvm::FunctionSpecializationPass());
      break;
    case CompilerGymPass::GVN:
      fpm.addPass(llvm::GVN());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::GVNHOIST:
      fpm.addPass(llvm::GVNHoistPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::GVNSINK:
      fpm.addPass(llvm::GVNSinkPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::GLOBAL_DCE:
      pm.addPass(llvm::GlobalDCEPass());
      break;
    case CompilerGymPass::GLOBAL_OPT:
      pm.addPass(llvm::GlobalOptPass());
      break;
    case CompilerGymPass::GLOBAL_SPLIT:
      pm.addPass(llvm::GlobalSplitPass());
      break;
    case CompilerGymPass::GUARD_WIDENING:
      fpm.addPass(llvm::GuardWideningPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::HELLO_WORLD:
      fpm.addPass(llvm::HelloWorldPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::HOT_COLD_SPLITTING:
      pm.addPass(llvm::HotColdSplittingPass());
      break;
    case CompilerGymPass::IPSCCP:
      pm.addPass(llvm::IPSCCPPass());
      break;
    case CompilerGymPass::IRCE:
      fpm.addPass(llvm::IRCEPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::IROUTLINER:
      pm.addPass(llvm::IROutlinerPass());
      break;
    case CompilerGymPass::INFER_ADDRESS_SPACES:
      fpm.addPass(llvm::InferAddressSpacesPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::INFER_FUNCTION_ATTRS:
      pm.addPass(llvm::InferFunctionAttrsPass());
      break;
    case CompilerGymPass::INJECT_TLIMAPPINGS:
      fpm.addPass(llvm::InjectTLIMappings());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::INST_COMBINE:
      fpm.addPass(llvm::InstCombinePass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::INST_SIMPLIFY:
      fpm.addPass(llvm::InstSimplifyPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::INSTRUCTION_NAMER:
      fpm.addPass(llvm::InstructionNamerPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::INTERNALIZE:
      pm.addPass(llvm::InternalizePass());
      break;
    case CompilerGymPass::JUMP_THREADING:
      fpm.addPass(llvm::JumpThreadingPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::LCSSA:
      fpm.addPass(llvm::LCSSAPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::LIB_CALLS_SHRINK_WRAP:
      fpm.addPass(llvm::LibCallsShrinkWrapPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::LOAD_STORE_VECTORIZER:
      fpm.addPass(llvm::LoadStoreVectorizerPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::LOOP_DATA_PREFETCH:
      fpm.addPass(llvm::LoopDataPrefetchPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::LOOP_DISTRIBUTE:
      fpm.addPass(llvm::LoopDistributePass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::LOOP_EXTRACTOR:
      pm.addPass(llvm::LoopExtractorPass());
      break;
    case CompilerGymPass::LOOP_FUSE:
      fpm.addPass(llvm::LoopFusePass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::LOOP_LOAD_ELIMINATION:
      fpm.addPass(llvm::LoopLoadEliminationPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::LOOP_SIMPLIFY:
      fpm.addPass(llvm::LoopSimplifyPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::LOOP_SINK:
      fpm.addPass(llvm::LoopSinkPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::LOOP_UNROLL:
      fpm.addPass(llvm::LoopUnrollPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::LOOP_VECTORIZE:
      fpm.addPass(llvm::LoopVectorizePass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::LOOP_VERSIONING:
      fpm.addPass(llvm::LoopVersioningPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::LOWER_ATOMIC:
      fpm.addPass(llvm::LowerAtomicPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::LOWER_CONSTANT_INTRINSICS:
      fpm.addPass(llvm::LowerConstantIntrinsicsPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::LOWER_EXPECT_INTRINSIC:
      fpm.addPass(llvm::LowerExpectIntrinsicPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::LOWER_GUARD_INTRINSIC:
      fpm.addPass(llvm::LowerGuardIntrinsicPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::LOWER_INVOKE:
      fpm.addPass(llvm::LowerInvokePass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::LOWER_MATRIX_INTRINSICS:
      fpm.addPass(llvm::LowerMatrixIntrinsicsPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::LOWER_SWITCH:
      fpm.addPass(llvm::LowerSwitchPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::LOWER_TYPE_TESTS:
      pm.addPass(llvm::LowerTypeTestsPass());
      break;
    case CompilerGymPass::LOWER_WIDENABLE_CONDITION:
      fpm.addPass(llvm::LowerWidenableConditionPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::MAKE_GUARDS_EXPLICIT:
      fpm.addPass(llvm::MakeGuardsExplicitPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::MEM_CPY_OPT:
      fpm.addPass(llvm::MemCpyOptPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::MERGE_FUNCTIONS:
      pm.addPass(llvm::MergeFunctionsPass());
      break;
    case CompilerGymPass::MERGE_ICMPS:
      fpm.addPass(llvm::MergeICmpsPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::MERGED_LOAD_STORE_MOTION:
      fpm.addPass(llvm::MergedLoadStoreMotionPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::META_RENAMER:
      pm.addPass(llvm::MetaRenamerPass());
      break;
    case CompilerGymPass::MODULE_INLINER_WRAPPER:
      pm.addPass(llvm::ModuleInlinerWrapperPass());
      break;
    case CompilerGymPass::NAME_ANON_GLOBAL:
      pm.addPass(llvm::NameAnonGlobalPass());
      break;
    case CompilerGymPass::NARY_REASSOCIATE:
      fpm.addPass(llvm::NaryReassociatePass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::NEW_GVN:
      fpm.addPass(llvm::NewGVNPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::OBJ_CARCAPELIM:
      pm.addPass(llvm::ObjCARCAPElimPass());
      break;
    case CompilerGymPass::OBJ_CARCCONTRACT:
      fpm.addPass(llvm::ObjCARCContractPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::OBJ_CARCEXPAND:
      fpm.addPass(llvm::ObjCARCExpandPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::OBJ_CARCOPT:
      fpm.addPass(llvm::ObjCARCOptPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::OPEN_MPOPT:
      pm.addPass(llvm::OpenMPOptPass());
      break;
    case CompilerGymPass::PARTIAL_INLINER:
      pm.addPass(llvm::PartialInlinerPass());
      break;
    case CompilerGymPass::PARTIALLY_INLINE_LIB_CALLS:
      fpm.addPass(llvm::PartiallyInlineLibCallsPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::PREDICATE_INFO_VERIFIER:
      fpm.addPass(llvm::PredicateInfoVerifierPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::PROMOTE:
      fpm.addPass(llvm::PromotePass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::PSEUDO_PROBE_UPDATE:
      pm.addPass(llvm::PseudoProbeUpdatePass());
      break;
    case CompilerGymPass::REASSOCIATE:
      fpm.addPass(llvm::ReassociatePass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::REDUNDANT_DBG_INST_ELIMINATION:
      fpm.addPass(llvm::RedundantDbgInstEliminationPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::REG_TO_MEM:
      fpm.addPass(llvm::RegToMemPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::REL_LOOKUP_TABLE_CONVERTER:
      pm.addPass(llvm::RelLookupTableConverterPass());
      break;
    case CompilerGymPass::REVERSE_POST_ORDER_FUNCTION_ATTRS:
      pm.addPass(llvm::ReversePostOrderFunctionAttrsPass());
      break;
    case CompilerGymPass::REWRITE_STATEPOINTS_FOR_GC:
      pm.addPass(llvm::RewriteStatepointsForGC());
      break;
    case CompilerGymPass::REWRITE_SYMBOL:
      pm.addPass(llvm::RewriteSymbolPass());
      break;
    case CompilerGymPass::SCCP:
      fpm.addPass(llvm::SCCPPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::SLPVECTORIZER:
      fpm.addPass(llvm::SLPVectorizerPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::SROA:
      fpm.addPass(llvm::SROA());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::SAMPLE_PROFILE_LOADER:
      pm.addPass(llvm::SampleProfileLoaderPass());
      break;
    case CompilerGymPass::SCALARIZE_MASKED_MEM_INTRIN:
      fpm.addPass(llvm::ScalarizeMaskedMemIntrinPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::SCALARIZER:
      fpm.addPass(llvm::ScalarizerPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::SEPARATE_CONST_OFFSET_FROM_GEP:
      fpm.addPass(llvm::SeparateConstOffsetFromGEPPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::SIMPLIFY_CFG:
      fpm.addPass(llvm::SimplifyCFGPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::SINKING:
      fpm.addPass(llvm::SinkingPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::SPECULATIVE_EXECUTION:
      fpm.addPass(llvm::SpeculativeExecutionPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::STRAIGHT_LINE_STRENGTH_REDUCE:
      fpm.addPass(llvm::StraightLineStrengthReducePass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::STRIP_DEAD_DEBUG_INFO:
      pm.addPass(llvm::StripDeadDebugInfoPass());
      break;
    case CompilerGymPass::STRIP_DEAD_PROTOTYPES:
      pm.addPass(llvm::StripDeadPrototypesPass());
      break;
    case CompilerGymPass::STRIP_DEBUG_DECLARE:
      pm.addPass(llvm::StripDebugDeclarePass());
      break;
    case CompilerGymPass::STRIP_GCRELOCATES:
      fpm.addPass(llvm::StripGCRelocates());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::STRIP_NON_DEBUG_SYMBOLS:
      pm.addPass(llvm::StripNonDebugSymbolsPass());
      break;
    case CompilerGymPass::STRIP_NON_LINE_TABLE_DEBUG_INFO:
      pm.addPass(llvm::StripNonLineTableDebugInfoPass());
      break;
    case CompilerGymPass::STRIP_SYMBOLS:
      pm.addPass(llvm::StripSymbolsPass());
      break;
    case CompilerGymPass::STRUCTURIZE_CFG:
      fpm.addPass(llvm::StructurizeCFGPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::SYNTHETIC_COUNTS_PROPAGATION:
      pm.addPass(llvm::SyntheticCountsPropagation());
      break;
    case CompilerGymPass::TAIL_CALL_ELIM:
      fpm.addPass(llvm::TailCallElimPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::UNIFY_FUNCTION_EXIT_NODES:
      fpm.addPass(llvm::UnifyFunctionExitNodesPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::UNIFY_LOOP_EXITS:
      fpm.addPass(llvm::UnifyLoopExitsPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::VECTOR_COMBINE:
      fpm.addPass(llvm::VectorCombinePass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::WARN_MISSED_TRANSFORMATIONS:
      fpm.addPass(llvm::WarnMissedTransformationsPass());
      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));
      break;
    case CompilerGymPass::WHOLE_PROGRAM_DEVIRT:
      pm.addPass(llvm::WholeProgramDevirtPass());
      break;
  }
}
