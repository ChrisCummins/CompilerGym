# Copyright (c) Facebook, Inc. and its affiliates.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.
"""Build generated files from a list of passes.

This script reads from stdin a description of passes (as generated by
extract_passes_from_sources.py) and generates files so that these passes can be
used as an action space by the LLVM environment.

Usage:

    $ make_action_space_genfiles.py <output-directory> < <pass-list>

The following files are generated:

<outdir>/ActionHeaders.h
------------------------
    Example:

        #pragma once
        #include "llvm/LinkAllPasses.h"
        #include "llvm/Transforms/AggressiveInstCombine/AggressiveInstCombine.h" ...

    This file includes the set of LLVM headers that must be included to use the
    passes.

<outdir>/ActionEnum.h
---------------------
    Example:

        enum class CompilerGymPass {
          ADD_DISCRIMINATORS_PASS, AGGRESSIVE_DCEPASS, ...
        }

    This defines an enum that names all of the passes.

<outdir>/ActionSwitch.h
-----------------------
    Example:

        #define HANDLE_ACTION(action, handlePass) \
          switch (action) {  \
            case CompilerGymPass::ADD_DISCRIMINATORS_PASS: \
              handlePass(llvm::createAddDiscriminatorsPass()); \
                break; \
            case CompilerGymPass::AGGRESSIVE_DCEPASS: \
              handlePass(llvm::createAggressiveDCEPass()); \
                break; \
          ...
        }

    To use the generated switch, call the HANDLE_ACTION() macro using an
    CompilerGymPass enum value and a handlePass function which accepts a pass
    instance as input.

<outdir>/flags.txt
-------------------------
    Example:

        -add-discriminators -adce ...

    A list of names for each pass.

<outdir>/flag_descriptions.txt
---------------------------------
    Example:

        Add DWARF path discriminators Aggressive Dead Code Elimination ...

    A list of descriptions of each pass.
"""
import json
import sys
from contextlib import contextmanager
from pathlib import Path
from typing import Dict, List

from absl import app, flags, logging

flags.DEFINE_string("outdir", "genfiles", "Output directory")

FLAGS = flags.FLAGS

header = """\
Copyright (c) Facebook, Inc. and its affiliates.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.

This file was automatically generated by make_action_space_sources.py.
"""
cxx_header = "\n".join(f"// {line}".rstrip() for line in header.splitlines())
py_header = "\n".join(f"# {line}".rstrip() for line in header.splitlines())


def split_camel_caps(string: str) -> List[str]:
    words = [[string[0]]]
    for c in string[1:]:
        if words[-1][-1].islower() and c.isupper():
            words.append(list(c))
        else:
            words[-1].append(c)
    return ["".join(word) for word in words]


def enumname(pass_: Dict[str, str]) -> str:
    return "_".join([x.upper() for x in split_camel_caps(pass_["class_name"])])


@contextmanager
def write(path: Path):
    with open(path, "w", encoding="utf-8") as f:
        if path.suffix == ".py":
            print(py_header, file=f)
        elif path.suffix == ".h" or path.suffix == ".cc":
            print(cxx_header, file=f)
        else:
            print(header, file=f)

        yield f
    logging.info("Wrote %s", path)


def make_action_space_sources(passes: List[Dict[str, str]], outdir: Path):
    """Generate the pass builder sources."""
    with write(outdir / "HandleActionMacroSwitch.h") as f:
        print(file=f)
        print("#define HANDLE_ACTION(action, handlePass) \\", file=f)
        print("  switch (action) {  \\", file=f)
        for pass_ in passes:
            print(f"    case CompilerGymPass::{enumname(pass_)}: \\", file=f)
            print(f"      handlePass({pass_['create_statement']}); \\", file=f)
            print("      break; \\", file=f)
        print("  }", file=f)

    with write(outdir / "ActionPassBuilder.h") as f:
        print('#include "llvm/Passes/PassBuilder.h"', file=f)
        print(file=f)
        print(
            "llvm::ModulePassManager createActionPipeline(CompilerGymPass action);",
            file=f,
        )

    with write(outdir / "ActionPassBuilder.cc") as f:
        print('#include "llvm/Passes/PassBuilder.h"', file=f)
        for header in sorted(set([p["header"] for p in passes])):
            print(f'#include "{header}"', file=f)
        print(file=f)
        print(
            "llvm::ModulePassManager createActionPipeline(CompilerGymPass action) {",
            file=f,
        )
        print("  llvm::ModulePassManager pm;", file=f)
        print("  switch (action) {", file=f)
        for pass_ in passes:
            print(f"    case CompilerGymPass::{enumname(pass_)}: \\", file=f)
            if pass_["type"] == "ModulePass":
                print(f"      pm.addPass({pass_['create_statement']});", file=f)
            elif pass_["type"] == "FunctionPass":
                print("      llvm::FunctionPassManager fpm;", file=f)
                print(f"      fpm.addPass({pass_['create_statement']});", file=f)
                print(
                    "      pm.addPass(createModuleToFunctionPassAdaptor(std::move(fpm)));",
                    file=f,
                )
            else:
                raise ValueError("Unhandled pass type")
            print("      break; \\", file=f)
        print("  return pm;", file=f)
        print("}", file=f)

    with write(outdir / "ActionEnums.h") as f:
        print(file=f)
        print("enum class CompilerGymPass {", file=f)
        for pass_ in passes:
            print(f"  {enumname(pass_)},", file=f)
        print("};", file=f)
        print(file=f)
        print("enum class CompilerGymModulePass {", file=f)
        for pass_ in passes:
            if pass_["type"] == "ModulePass":
                print(f"  {enumname(pass_)},", file=f)
        print("};", file=f)
        print(file=f)
        print("enum class CompilerGymFunctionPass {", file=f)
        for pass_ in passes:
            if pass_["type"] == "FunctionPass":
                print(f"  {enumname(pass_)},", file=f)
        print("};", file=f)

    with write(outdir / "ActionHeader.h") as f:
        print(file=f)
        print("#pragma once\n", file=f)
        for header_ in sorted(set([p["header"] for p in passes])):
            print(f'#include "{header_}"', file=f)

    with write(outdir / "actions.py") as f:
        print("from enum import Enum\n", file=f)
        print("class actions(Enum):", file=f)
        for pass_ in passes:
            print(f"    {enumname(pass_)} = {pass_}", file=f)

    with write(outdir / "CommandLineFlag.cc") as f:
        print(
            """\
#include "llvm/Support/CommandLine.h"

static cl::list<CompilerGymPass> CompilerGymPassList(
    "cg-passes",
    cl::desc("A list of passes to run"),
    cl::ZeroOrMore,
    cl::values(""",
            file=f,
        )
        for pass_ in passes:
            print(f'        clEnumVal({enumname(pass_)}, ""),', file=f)
        print("    cl::CommaSeparated);", file=f)


def main(argv):
    """Main entry point."""
    assert len(argv) == 1, f"Unknown flags: {argv[1:]}"

    outdir = Path(FLAGS.outdir)
    outdir.mkdir(exist_ok=True, parents=True)

    passes = json.load(sys.stdin)

    make_action_space_sources(passes, outdir)


if __name__ == "__main__":
    app.run(main)
